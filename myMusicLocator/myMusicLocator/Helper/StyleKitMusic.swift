//
//  StyleKitMusic.swift
//  Music
//
//  Created by Christian Andersen on 06/08/2018.
//  Copyright Â© 2018 CA. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//
// Bruger normalt stylekit - men ikke i det her projekt - Christian Andersen


import UIKit

public class StyleKitMusic : NSObject {

    //// Cache

    private struct Cache {
        static var imageOfCancelN: UIImage?
        static var cancelNTargets: [AnyObject]?
        static var imageOfCancelP: UIImage?
        static var cancelPTargets: [AnyObject]?
        static var imageOfSearchIconN: UIImage?
        static var searchIconNTargets: [AnyObject]?
    }

    //// Drawing Methods

    @objc dynamic public class func drawCancelN() {
        //// Color Declarations
        let color4 = UIColor(red: 0.494, green: 0.710, blue: 0.227, alpha: 1.000)

        //// cancel4.svg Group
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 37.5, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 0, y: 37.5), controlPoint1: CGPoint(x: 16.79, y: 0), controlPoint2: CGPoint(x: 0, y: 16.8))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 75), controlPoint1: CGPoint(x: 0, y: 58.21), controlPoint2: CGPoint(x: 16.79, y: 75))
        bezierPath.addCurve(to: CGPoint(x: 75, y: 37.5), controlPoint1: CGPoint(x: 58.22, y: 75), controlPoint2: CGPoint(x: 75, y: 58.21))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 0), controlPoint1: CGPoint(x: 75, y: 16.8), controlPoint2: CGPoint(x: 58.22, y: 0))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 60.89, y: 50.04))
        bezierPath.addLine(to: CGPoint(x: 50.04, y: 60.88))
        bezierPath.addLine(to: CGPoint(x: 37.5, y: 48.34))
        bezierPath.addLine(to: CGPoint(x: 24.96, y: 60.88))
        bezierPath.addLine(to: CGPoint(x: 14.12, y: 50.04))
        bezierPath.addLine(to: CGPoint(x: 26.66, y: 37.49))
        bezierPath.addLine(to: CGPoint(x: 14.12, y: 24.96))
        bezierPath.addLine(to: CGPoint(x: 24.96, y: 14.12))
        bezierPath.addLine(to: CGPoint(x: 37.5, y: 26.65))
        bezierPath.addLine(to: CGPoint(x: 50.04, y: 14.12))
        bezierPath.addLine(to: CGPoint(x: 60.89, y: 24.96))
        bezierPath.addLine(to: CGPoint(x: 48.34, y: 37.49))
        bezierPath.addLine(to: CGPoint(x: 60.89, y: 50.04))
        bezierPath.close()
        color4.setFill()
        bezierPath.fill()




        //// Group 3


        //// Group 4


        //// Group 5


        //// Group 6


        //// Group 7


        //// Group 8


        //// Group 9


        //// Group 10


        //// Group 11


        //// Group 12


        //// Group 13


        //// Group 14


        //// Group 15


        //// Group 16


        //// Group 17
    }

    @objc dynamic public class func drawCancelP() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let color4 = UIColor(red: 0.494, green: 0.710, blue: 0.227, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black
        shadow.shadowOffset = CGSize(width: 3, height: 3)
        shadow.shadowBlurRadius = 5

        //// cancel4.svg Group
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 37.5, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 0, y: 37.5), controlPoint1: CGPoint(x: 16.79, y: 0), controlPoint2: CGPoint(x: 0, y: 16.8))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 75), controlPoint1: CGPoint(x: 0, y: 58.21), controlPoint2: CGPoint(x: 16.79, y: 75))
        bezierPath.addCurve(to: CGPoint(x: 75, y: 37.5), controlPoint1: CGPoint(x: 58.22, y: 75), controlPoint2: CGPoint(x: 75, y: 58.21))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 0), controlPoint1: CGPoint(x: 75, y: 16.8), controlPoint2: CGPoint(x: 58.22, y: 0))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 60.89, y: 50.04))
        bezierPath.addLine(to: CGPoint(x: 50.04, y: 60.88))
        bezierPath.addLine(to: CGPoint(x: 37.5, y: 48.34))
        bezierPath.addLine(to: CGPoint(x: 24.96, y: 60.88))
        bezierPath.addLine(to: CGPoint(x: 14.12, y: 50.04))
        bezierPath.addLine(to: CGPoint(x: 26.66, y: 37.49))
        bezierPath.addLine(to: CGPoint(x: 14.12, y: 24.96))
        bezierPath.addLine(to: CGPoint(x: 24.96, y: 14.12))
        bezierPath.addLine(to: CGPoint(x: 37.5, y: 26.65))
        bezierPath.addLine(to: CGPoint(x: 50.04, y: 14.12))
        bezierPath.addLine(to: CGPoint(x: 60.89, y: 24.96))
        bezierPath.addLine(to: CGPoint(x: 48.34, y: 37.49))
        bezierPath.addLine(to: CGPoint(x: 60.89, y: 50.04))
        bezierPath.close()
        color4.setFill()
        bezierPath.fill()

        ////// Bezier Inner Shadow
        context.saveGState()
        context.clip(to: bezierPath.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0)
        context.setAlpha((shadow.shadowColor as! UIColor).cgColor.alpha)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let bezierOpaqueShadow = (shadow.shadowColor as! UIColor).withAlphaComponent(1)
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: bezierOpaqueShadow.cgColor)
        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        bezierOpaqueShadow.setFill()
        bezierPath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        context.restoreGState()





        //// Group 3


        //// Group 4


        //// Group 5


        //// Group 6


        //// Group 7


        //// Group 8


        //// Group 9


        //// Group 10


        //// Group 11


        //// Group 12


        //// Group 13


        //// Group 14


        //// Group 15


        //// Group 16


        //// Group 17
    }

    @objc dynamic public class func drawSearchIconN() {
        //// Color Declarations
        let color4 = UIColor(red: 0.494, green: 0.710, blue: 0.227, alpha: 1.000)
        let fillColor3 = UIColor(red: 1.000, green: 0.998, blue: 0.995, alpha: 1.000)

        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0.25, y: -0.17, width: 74.5, height: 74.5))
        color4.setFill()
        ovalPath.fill()




        //// magnifying.svg Group
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 42.19, y: 25.46))
        bezierPath.addCurve(to: CGPoint(x: 25.46, y: 25.46), controlPoint1: CGPoint(x: 37.58, y: 20.85), controlPoint2: CGPoint(x: 30.07, y: 20.85))
        bezierPath.addCurve(to: CGPoint(x: 25.46, y: 42.19), controlPoint1: CGPoint(x: 20.85, y: 30.07), controlPoint2: CGPoint(x: 20.85, y: 37.58))
        bezierPath.addCurve(to: CGPoint(x: 40.58, y: 43.53), controlPoint1: CGPoint(x: 29.57, y: 46.3), controlPoint2: CGPoint(x: 35.97, y: 46.74))
        bezierPath.addCurve(to: CGPoint(x: 41.25, y: 44.79), controlPoint1: CGPoint(x: 40.67, y: 43.99), controlPoint2: CGPoint(x: 40.89, y: 44.43))
        bezierPath.addLine(to: CGPoint(x: 47.97, y: 51.51))
        bezierPath.addCurve(to: CGPoint(x: 51.5, y: 51.51), controlPoint1: CGPoint(x: 48.95, y: 52.48), controlPoint2: CGPoint(x: 50.53, y: 52.48))
        bezierPath.addCurve(to: CGPoint(x: 51.5, y: 47.97), controlPoint1: CGPoint(x: 52.48, y: 50.53), controlPoint2: CGPoint(x: 52.48, y: 48.95))
        bezierPath.addLine(to: CGPoint(x: 44.79, y: 41.25))
        bezierPath.addCurve(to: CGPoint(x: 43.53, y: 40.58), controlPoint1: CGPoint(x: 44.43, y: 40.9), controlPoint2: CGPoint(x: 43.99, y: 40.67))
        bezierPath.addCurve(to: CGPoint(x: 42.19, y: 25.46), controlPoint1: CGPoint(x: 46.74, y: 35.97), controlPoint2: CGPoint(x: 46.3, y: 29.57))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 40.07, y: 40.07))
        bezierPath.addCurve(to: CGPoint(x: 27.58, y: 40.07), controlPoint1: CGPoint(x: 36.63, y: 43.52), controlPoint2: CGPoint(x: 31.02, y: 43.52))
        bezierPath.addCurve(to: CGPoint(x: 27.58, y: 27.58), controlPoint1: CGPoint(x: 24.14, y: 36.63), controlPoint2: CGPoint(x: 24.14, y: 31.03))
        bezierPath.addCurve(to: CGPoint(x: 40.07, y: 27.58), controlPoint1: CGPoint(x: 31.02, y: 24.14), controlPoint2: CGPoint(x: 36.63, y: 24.14))
        bezierPath.addCurve(to: CGPoint(x: 40.07, y: 40.07), controlPoint1: CGPoint(x: 43.52, y: 31.03), controlPoint2: CGPoint(x: 43.52, y: 36.63))
        bezierPath.close()
        fillColor3.setFill()
        bezierPath.fill()




        //// Group 3


        //// Group 4


        //// Group 5


        //// Group 6


        //// Group 7


        //// Group 8


        //// Group 9


        //// Group 10


        //// Group 11


        //// Group 12


        //// Group 13


        //// Group 14


        //// Group 15


        //// Group 16


        //// Group 17
    }

    //WARNING: Drawing method for 'SearchIconP' cannot be generated due to Trial limits.

    //// Generated Images

    @objc dynamic public class var imageOfCancelN: UIImage {
        if Cache.imageOfCancelN != nil {
            return Cache.imageOfCancelN!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 50, height: 50), false, 0)
            StyleKitMusic.drawCancelN()

        Cache.imageOfCancelN = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return Cache.imageOfCancelN!
    }

    @objc dynamic public class var imageOfCancelP: UIImage {
        if Cache.imageOfCancelP != nil {
            return Cache.imageOfCancelP!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 50, height: 50), false, 0)
            StyleKitMusic.drawCancelP()

        Cache.imageOfCancelP = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return Cache.imageOfCancelP!
    }

    @objc dynamic public class var imageOfSearchIconN: UIImage {
        if Cache.imageOfSearchIconN != nil {
            return Cache.imageOfSearchIconN!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 50, height: 50), false, 0)
            StyleKitMusic.drawSearchIconN()

        Cache.imageOfSearchIconN = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return Cache.imageOfSearchIconN!
    }

    //WARNING: Image method for 'SearchIconP' cannot be generated due to Trial limits.

    //// Customization Infrastructure

    @objc @IBOutlet dynamic var cancelNTargets: [AnyObject]! {
        get { return Cache.cancelNTargets }
        set {
            Cache.cancelNTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKitMusic.imageOfCancelN)
            }
        }
    }

    @objc @IBOutlet dynamic var cancelPTargets: [AnyObject]! {
        get { return Cache.cancelPTargets }
        set {
            Cache.cancelPTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKitMusic.imageOfCancelP)
            }
        }
    }

    @objc @IBOutlet dynamic var searchIconNTargets: [AnyObject]! {
        get { return Cache.searchIconNTargets }
        set {
            Cache.searchIconNTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKitMusic.imageOfSearchIconN)
            }
        }
    }

}
